/**
 * signals are limited form of IPC typically used in linux OD
 * -its a way to communication information to a process about the state of other processes, the OS, and hardware
 * -generated by the system or the user can also generate it
 * -a process can receive a signal asynchronously (at any time)
 * -it has to stop what its doing and deal with the signal
 * 
 * Examples:
 * Ctrl -C - > SIGINT
 * Ctrl - Z -> SIGSTP
 * fg or bg -> SIGCONT
 * 
 * In terminal: kill -l will list all signals
 * 
 * <signal.h> - libaries to raise specific signals
 *  */

#include <stdio.h>
#include <signal.h>
#include <unistd.h>

int main(void) {

    // int raise(int sig) - raises a signal
    // if successful, the signal specific in sig is generated and returns 0, otherwise raise() returns a non-zero value
    // the function raise() can only send a singla to the program that contains it (i,e, cannot send to other proccess). to send to other processes you have to use kill()
    printf("Testing SIGSTOP\n");
    // raise(SIGSTOP);
    // you can resume it by doing kill -s SIGCONT <PID>
    printf("I am back\n\n");


    alarm(5);

    for (int i = 1; i < 10; i++) {
        printf("%d\n", i);
        sleep(1);
    }

    // the alarm() function provides a mechanism for a process to interrupt itself in the future
    // it sets a timer, when the timer expires, the process receives a signal (SIGALARM)
    // if we ignore or do not catch the signal, the process is terminated (the default action)
    // there is only one alarm clock per process
    return 0;
}